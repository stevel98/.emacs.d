package gitlet;

import java.io.File;
import java.io.Serializable;
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.FileInputStream;
import java.io.ObjectInputStream;
import java.io.IOException;

import java.nio.file.Paths;

import static gitlet.Utils.*;
import static java.io.File.separator;

/** Encapsulates a file and its SHA1 hash.
 *
 *  @author Steve Li
 */
class Blob implements Serializable {

    /** The internal path where all blobs are stored. */
    static final String INTERNAL_PATH = Paths.get(".gitlet", "blobs")
        .toString() + separator;

    /** Returns internal path where all gitlet objects are stored. */
    static String internalPath() {
        return INTERNAL_PATH;
    }

    /** Where I am stored. */
    private final String serializationPath;

    /** Return my serialization path. */
    String serializationPath() {
        return serializationPath;
    }

    /** Compute and return the SHA1 hash of BLOB. */
    static String computeSHA1(Blob blob) {
        return sha1(blob.name(), blob.contents());
    }

    /** Return the concatenation of HEAD and TOMERGE, with HEAD
     *  first, also writing it to the working directory.
     *  Assumes HEAD and TOMERGE have merge conflicts and
     *  point to the same file. */
    static Blob mergedBlob(Blob head, Blob toMerge) {
        File F;
        if (head == null) {
            F = new File(toMerge.name());
        } else {
            F = new File(head.name());
        }
        byte[] headContents;
        byte[] toMergeContents;

        if (head == null) {
            headContents = new byte[0];
        } else {
            headContents = head.contents();
        }

        if (toMerge == null) {
            toMergeContents = new byte[0];
        } else {
            toMergeContents = toMerge.contents();
        }

        writeContents(F, START_DELIMITER, headContents,
                      MID_DELIMITER, toMergeContents,
                      END_DELIMITER);
        return new Blob(F);
    }

    /** Return the concatenation of HEADID and TOMERGEID, assuming
     *  they have conflicts and overwrite the file in the current
     *  working directory. */
    static Blob mergedBlob(String headID, String toMergeID) {
        return mergedBlob(getBlob(headID), getBlob(toMergeID));
    }

    /** Return the blob with id ID. */
    static Blob getBlob(String id) {
        if (id == null) {
            return null;
        }
        return deserialize(id);
    }

    /** Deserialize and return the Blob with id ID. */
    static Blob deserialize(String id) {
        Blob blob;
        File inFile = new File(INTERNAL_PATH + id);
        try {
            ObjectInputStream inp =
                new ObjectInputStream(new FileInputStream(inFile));
            blob = (Blob) inp.readObject();
            inp.close();
        } catch (IOException | ClassNotFoundException excp) {
            blob = null;
        }
        return blob;
    }

    /** Serialize me to my serializationPath. */
    void serialize() {
        Blob me = this;
        File outFile = new File(serializationPath);
        try {
            ObjectOutputStream out =
                new ObjectOutputStream(new FileOutputStream(outFile));
            out.writeObject(me);
            out.close();
        } catch (IOException excp) {
            throw new GitletException("fatal: unable to serialize blob "
                                      + me.id());
        }
    }

    /** Return a blob with name NAME and contents CONTENTS. */
    Blob(String name, byte[] contents) {
        _name = name;
        _contents = contents;
        _id = computeSHA1(this);
        serializationPath = INTERNAL_PATH + _id;
    }

    /** Return a Blob constructed from F. */
    Blob(File f) {
        this(f.getName(), readContents(f));
    }

    /** Return the name of my file. */
    String name() {
        return _name;
    }

    /** Return my SHA-1 hash. */
    String id() {
        return _id;
    }

    /** Return my contents. */
    byte[] contents() {
        return _contents;
    }

    /** The name of my file. */
    private String _name;

    /** The SHA-1 hash of my contents. */
    private String _id;

    /** My contents. */
    private byte[] _contents;

    /** Delimiter for merge conflict file. */
    private static final String START_DELIMITER =
        "<<<<<<< HEAD\n";

    /** Delimiter for merge conflict file. */
    private static final String MID_DELIMITER =
        "=======\n";

    /** Delimiter for merge conflict file. */
    private static final String END_DELIMITER =
        ">>>>>>>\n";

}
