package gitlet;

import java.util.Date;
import java.text.DateFormat;
import java.text.SimpleDateFormat;

import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Set;

import java.io.Serializable;
import java.io.File;
import java.io.IOException;
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.FileInputStream;
import java.io.ObjectInputStream;

import java.nio.file.Paths;

import static java.io.File.separator;
import static gitlet.Utils.*;


/** A commit object, usually stored in serialized form, deserialized only
 *  as needed.
 *
 *  @author Steve Li
 */
class Commit implements Serializable {

    /** The absolute path of the directory where we store commits. */
    static final String INTERNAL_PATH = Paths.get(".gitlet",
        "commits").toString() + separator;

    /** The path were I am stored. */
    private final String serializationPath;

    /** The initial commit. */
    static final InitialCommit INIT = new InitialCommit();

    /** For formatting dates. */
    static final DateFormat DATE_FORMATTER =
        new SimpleDateFormat("EEE MMM dd HH:mm:ss yyyy ZZZZZ");

    /** Deserialize and return the commit with commit id ID in .gitlet/commits.
     *  Throws GitletException if not found. */
    static Commit deserialize(String id) {
        Commit commit;
        File inFile = new File(INTERNAL_PATH + id);
        try {
            ObjectInputStream inp =
                new ObjectInputStream(new FileInputStream(inFile));
            commit = (Commit) inp.readObject();
            inp.close();
        } catch (IOException | ClassNotFoundException excp) {
            throw new GitletException("No commit with that id exists.");
        }

        return commit;
    }

    /** Serialize me to serializationPath. */
    void serialize() {
        Commit obj = this;
        File outFile = new File(serializationPath);
        try {
            ObjectOutputStream out =
                new ObjectOutputStream(new FileOutputStream(outFile));
            out.writeObject(obj);
            out.close();
        } catch (IOException excp) {
            obj = null;
        }
    }

    /** Compute and return COMMIT's SHA1 hash. */
    static String computeSha1(Commit commit) {
        List<Object> data = new ArrayList<Object>();
        String[] fields = new String[] {
            commit.parentID(),
            commit.msg(),
            commit.date(),
            commit.mergeParentID(),
        };

        for (String field : fields) {
            if (field != null) {
                data.add(field);
            }
        }
        for (String fileName : commit.blobs().keySet()) {
            data.add(fileName);
            data.add(commit.blobs().get(fileName));
        }

        return sha1(data);
    }

    /** Construct a new commit. Also sets serializationPath.
     *
     *  @param PARENTID
     *  @param MSG
     *  @param FILES
     *  @param MERGEPARENTID
     *  @param DATE
     */
    Commit(String parentID, String msg, HashMap<String, String> files,
            String date, String mergeParentID) {
        _parentID = parentID;
        _mergeParentID = mergeParentID;
        _msg = msg;
        _blobs = files;
        _date = date;
        _id = computeSha1(this);
        serializationPath = INTERNAL_PATH + _id;
    }

    /** Construct a new commit at the current time. Also sets SERIALIZATION
     *  PATH.
     *
     *  @param PARENTID
     *  @param MSG
     *  @param FILES
     */
    Commit(String parentID, String msg, HashMap<String, String> files) {
        this(parentID, msg, files, DATE_FORMATTER.format(new Date()), null);
    }

    /** Construct a new commit at the current time. Also sets SERIALIZATION
     *  PATH. Allows for setting MERGEPARENT.
     *
     *  @param PARENTID
     *  @param MSG
     *  @param FILES
     *  @param MERGEPARENTID
     */
    Commit(String parentID, String msg, HashMap<String, String> files,
           String mergeParentID) {
        this(parentID, msg, files, DATE_FORMATTER.format(new Date()),
             mergeParentID);
    }

    /** Return the blob id associated with FILENAME in _blobs, if it exists. */
    String getBlobID(String fileName) {
        return _blobs.get(fileName);
    }

    /** Return the Blob associated with FILENAME in me, if it exists. */
    Blob getBlob(String fileName) {
        return Blob.deserialize(_blobs.get(fileName));
    }

    /** Return the names of all the blobs I am tracking. Return type is a
     *  set for because of how keySet() works. (clean up later?) */
    Set<String> tracking() {
        return _blobs.keySet();
    }

    /** Return whether FILENAME is being tracked by this commit. */
    boolean isTracking(String fileName) {
        return _blobs.get(fileName) != null;
    }

    /** Return whether FOREIGNID is the same blob id as one I am tracking
     *  under FILENAME. */
    boolean contains(String fileName, String foreignID) {
        String myBlobID = _blobs.get(fileName);
        if (myBlobID == null) {
            return false;
        } else {
            return myBlobID.equals(foreignID);
        }
    }

    /** Return my hashmap of names to Blob IDs. */
    HashMap<String, String> blobs() {
        return _blobs;
    }

    /** Return all the IDs of the blobs I'm tracking. */
    List<String> blobIDs() {
        List<String> myIDs = new ArrayList<String>();
        for (String fileName : _blobs.keySet()) {
            myIDs.add(_blobs.get(fileName));
        }

        return myIDs;
    }

    /** Return my id. */
    String id() {
        return _id;
    }

    /** Return the id of my parent. */
    String parentID() {
        return _parentID;
    }

    /** Return the id of my parent if I was a merge commit, null otherwise. */
    String mergeParentID() {
        return _mergeParentID;
    }

    /** Return my date. */
    String date() {
        return _date;
    }

    /** Return my commit message. */
    String msg() {
        return _msg;
    }

    /** Return my log. */
    String log() {
        if (_mergeParentID == null) {
            return String.format(UNMERGED_LOG_FORMAT, _id, _date, _msg);
        } else {
            return String.format(MERGED_LOG_FORMAT, _id,
                                _parentID.substring(0, 7),
                                _mergeParentID.substring(0, 7),
                                _date, _msg);
        }
    }

    @Override
    public String toString() {
        return log();
    }

    /** Return my serialization path. */
    String serializationPath() {
        return serializationPath;
    }

    /** My id, implemented as SHA1 hash. */
    private String _id;

    /** The id of my parent commit. */
    private String _parentID;

    /** The id of my second parent, if I was created from a merge. */
    private String _mergeParentID;

    /** Date of birth. */
    private String _date;

    /** My commit message. */
    private String _msg;

    /** The files that I contain, mapped as filename -> SHA1(file). */
    private HashMap<String, String> _blobs;

    /** The log format for unmerged commits. */
    static final String UNMERGED_LOG_FORMAT = "===\ncommit %s\nDate: %s\n%s";

    /** The log format for merged commits. */
    static final String MERGED_LOG_FORMAT =
        "===\n"
        + "commit %s\n"
        + "Merge: %s %s\n"
        + "Date: %s\n"
        + "%s";

    /** The Unix Epoch. */
    static final String UNIX_EPOCH = "Thu Jan 1 00:00:00 1970 +0000";

    /** The initial commit message. */
    static final String INITIAL_MSG = "initial commit";

    /** The message for merges. */
    static final String MERGE_MSG = "Merged %s into %s.";

    /** Message printed if merge conflicts are encountered. */
    private static final String CONFLICT_MSG = "Encountered a merge conflict.";

    /** The initial commit. */
    static class InitialCommit extends Commit {

        /** Construct the initial commit. */
        InitialCommit() {
            super(null, INITIAL_MSG, new HashMap<String, String>(),
                UNIX_EPOCH, null);
        }
    }
}
